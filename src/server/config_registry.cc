// Copyright 2023, Roman Gershman.  All rights reserved.
// See LICENSE for licensing terms.
//
#include "server/config_registry.h"

#include <absl/flags/reflection.h>
#include <absl/strings/str_replace.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

#include <filesystem>
#include <fstream>

#include "base/logging.h"
#include "core/glob_matcher.h"
#include "server/common.h"
#include "server/server_family.h"

namespace dfly {
namespace {
using namespace std;

string NormalizeConfigName(string_view name) {
  return absl::StrReplaceAll(name, {{"-", "_"}});
}
}  // namespace

// Returns true if the value was updated.
auto ConfigRegistry::Set(string_view config_name, string_view value) -> SetResult {
  string name = NormalizeConfigName(config_name);

  util::fb2::LockGuard lk(mu_);
  auto it = registry_.find(name);
  if (it == registry_.end())
    return SetResult::UNKNOWN;
  if (!it->second.is_mutable)
    return SetResult::READONLY;

  auto cb = it->second.cb;

  absl::CommandLineFlag* flag = absl::FindCommandLineFlag(name);
  CHECK(flag) << config_name;
  if (string error; !flag->ParseFrom(value, &error)) {
    LOG(WARNING) << error;
    return SetResult::INVALID;
  }

  bool success = !cb || cb(*flag);
  if (success) {
    set_by_user_.insert(name);
  }
  return success ? SetResult::OK : SetResult::INVALID;
}

optional<string> ConfigRegistry::Get(string_view config_name) {
  string name = NormalizeConfigName(config_name);

  {
    util::fb2::LockGuard lk(mu_);
    if (!registry_.contains(name))
      return nullopt;
  }

  absl::CommandLineFlag* flag = absl::FindCommandLineFlag(name);
  CHECK(flag);
  return flag->CurrentValue();
}

void ConfigRegistry::Reset() {
  util::fb2::LockGuard lk(mu_);
  registry_.clear();
}

vector<string> ConfigRegistry::List(string_view glob) const {
  string normalized_glob = NormalizeConfigName(glob);
  GlobMatcher matcher(normalized_glob, false /* case insensitive*/);

  vector<string> res;
  util::fb2::LockGuard lk(mu_);

  for (const auto& [name, _] : registry_) {
    if (matcher.Matches(name))
      res.push_back(name);
  }
  return res;
}

void ConfigRegistry::RegisterInternal(string_view config_name, bool is_mutable, WriteCb cb) {
  string name = NormalizeConfigName(config_name);

  absl::CommandLineFlag* flag = absl::FindCommandLineFlag(name);
  CHECK(flag) << "Unknown config name: " << name;

  util::fb2::LockGuard lk(mu_);
  auto [it, inserted] = registry_.emplace(name, Entry{std::move(cb), is_mutable});
  CHECK(inserted) << "Duplicate config name: " << name;
}

bool ConfigRegistry::Rewrite() const {
  absl::CommandLineFlag* flagfile_flag = absl::FindCommandLineFlag("flagfile");
  if (!flagfile_flag)
    return false;
  std::string config_file_path = flagfile_flag->CurrentValue();
  if (config_file_path.empty())
    return false;
  std::filesystem::path config_path(config_file_path);
  if (!std::filesystem::exists(config_path))
    return false;
  std::ifstream config_file(config_path);
  if (!config_file.is_open())
    return false;
  std::vector<std::string> lines;
  std::string line;
  bool in_rewrite = false;
  std::map<std::string, size_t> orig_pos;
  std::map<std::string, std::string> rewrite_configs;
  size_t idx = 0;
  while (std::getline(config_file, line)) {
    lines.push_back(line);
    if (line == "# Generated by CONFIG REWRITE") {
      in_rewrite = true;
      continue;
    }
    if (in_rewrite && !line.empty() && line[0] != '#') {
      if (line.find("--") == 0) {
        auto eq = line.find('=');
        if (eq != std::string::npos) {
          std::string k = line.substr(2, eq - 2);
          std::string v = line.substr(eq + 1);
          rewrite_configs[k] = v;
        }
      }
      continue;
    }
    if (in_rewrite && line.empty())
      in_rewrite = false;
    if (!in_rewrite && line.find("--") == 0) {
      auto eq = line.find('=');
      if (eq != std::string::npos) {
        std::string k = line.substr(2, eq - 2);
        orig_pos[k] = idx;
      }
    }
    ++idx;
  }
  config_file.close();
  std::set<std::string> rewrite_now;
  {
    util::fb2::LockGuard lk(mu_);
    rewrite_now = set_by_user_;
  }
  // Update original items
  for (const auto& name : rewrite_now) {
    auto it = orig_pos.find(name);
    if (it != orig_pos.end()) {
      absl::CommandLineFlag* flag = absl::FindCommandLineFlag(name);
      if (flag) {
        lines[it->second] = "--" + name + "=" + flag->CurrentValue();
      }
    }
  }
  // Clean up old rewrite section
  while (!lines.empty() && lines.back().empty())
    lines.pop_back();
  while (!lines.empty() && lines.back() != "# Generated by CONFIG REWRITE") {
    if (lines.back().find("--") == 0)
      lines.pop_back();
    else
      break;
  }
  if (!lines.empty() && lines.back() == "# Generated by CONFIG REWRITE")
    lines.pop_back();
  // Generate new rewrite section
  std::map<std::string, std::string> final_rewrite;
  for (const auto& [k, v] : rewrite_configs) {
    if (orig_pos.find(k) == orig_pos.end())
      final_rewrite[k] = v;
  }
  for (const auto& name : rewrite_now) {
    if (orig_pos.find(name) == orig_pos.end()) {
      absl::CommandLineFlag* flag = absl::FindCommandLineFlag(name);
      if (flag)
        final_rewrite[name] = flag->CurrentValue();
    }
  }
  if (!final_rewrite.empty()) {
    lines.push_back("");
    lines.push_back("# Generated by CONFIG REWRITE");
    for (const auto& [k, v] : final_rewrite) {
      lines.push_back("--" + k + "=" + v);
    }
  }
  std::string content;
  for (const auto& l : lines)
    content += l + "\n";
  // Atomic write
  std::string tmp_template = config_file_path + ".tmpXXXXXX";
  std::vector<char> tmp_path(tmp_template.begin(), tmp_template.end());
  tmp_path.push_back('\0');
  int fd = mkstemp(tmp_path.data());
  if (fd == -1)
    return false;
  size_t off = 0;
  while (off < content.size()) {
    ssize_t n = write(fd, content.c_str() + off, content.size() - off);
    if (n <= 0) {
      close(fd);
      unlink(tmp_path.data());
      return false;
    }
    off += n;
  }
  fsync(fd);
  fchmod(fd, 0644);
  close(fd);
  if (rename(tmp_path.data(), config_file_path.c_str()) == -1) {
    unlink(tmp_path.data());
    return false;
  }
  // sync dir
  int dir_fd = open(std::filesystem::path(config_file_path).parent_path().c_str(), O_RDONLY);
  if (dir_fd != -1) {
    fsync(dir_fd);
    close(dir_fd);
  }
  return true;
}

ConfigRegistry config_registry;

}  // namespace dfly
